/**
 * Export utilities for EVA ERP Assistant consultations
 */

const PDFDocument = require('pdfkit');
const { Document, Packer, Paragraph, TextRun, HeadingLevel } = require('docx');
const fs = require('fs');
const path = require('path');

const generatePDFReport = async (conversation, options = {}) => {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({ 
        margin: 50,
        size: 'A4'
      });
      
      let buffers = [];
      doc.on('data', buffers.push.bind(buffers));
      doc.on('end', () => {
        const pdfData = Buffer.concat(buffers);
        resolve(pdfData);
      });

      // Header
      doc.fontSize(24)
         .fillColor('#3B82F6')
         .text('EVA ERP Consultation Report', { align: 'center' });
      
      doc.moveDown();
      doc.fontSize(12)
         .fillColor('#6B7280')
         .text(`Generated on: ${new Date().toLocaleDateString()}`, { align: 'center' });
      
      doc.moveDown(2);

      // Conversation details
      if (conversation.persona) {
        doc.fontSize(14)
           .fillColor('#1F2937')
           .text(`Consultant: ${formatPersonaName(conversation.persona)}`);
        doc.moveDown();
      }

      if (conversation.requirements) {
        doc.fontSize(16)
           .fillColor('#1F2937')
           .text('Business Requirements', { underline: true });
        doc.moveDown(0.5);
        
        doc.fontSize(12);
        doc.text(`Business Type: ${conversation.requirements.businessType}`);
        doc.text(`Current System: ${conversation.requirements.currentSystem}`);
        if (conversation.requirements.budget) {
          doc.text(`Budget: ${conversation.requirements.budget}`);
        }
        if (conversation.requirements.timeline) {
          doc.text(`Timeline: ${conversation.requirements.timeline}`);
        }
        doc.moveDown();
      }

      // Messages
      doc.fontSize(16)
         .fillColor('#1F2937')
         .text('Consultation Transcript', { underline: true });
      doc.moveDown(0.5);

      conversation.messages.forEach((message, index) => {
        // Speaker label
        doc.fontSize(12)
           .fillColor(message.role === 'user' ? '#059669' : '#3B82F6')
           .text(message.role === 'user' ? 'Client:' : 'EVA:', { continued: false });
        
        // Message content
        doc.fontSize(11)
           .fillColor('#374151')
           .text(message.content, { 
             indent: 20,
             align: 'left',
             width: 500
           });
        
        doc.moveDown(0.8);
        
        // Page break if needed
        if (doc.y > 700) {
          doc.addPage();
        }
      });

      // Code snippets section
      if (options.includeCode && conversation.codeSnippets) {
        doc.addPage();
        doc.fontSize(16)
           .fillColor('#1F2937')
           .text('Generated Code Snippets', { underline: true });
        doc.moveDown();

        conversation.codeSnippets.forEach((snippet, index) => {
          doc.fontSize(14)
             .fillColor('#DC2626')
             .text(`${snippet.type.toUpperCase()} Code:`);
          
          doc.fontSize(10)
             .fillColor('#1F2937')
             .text(snippet.code, {
               indent: 20,
               width: 500
             });
          
          doc.moveDown();
        });
      }

      // Footer
      doc.fontSize(10)
         .fillColor('#9CA3AF')
         .text('Generated by EVA - ERP Virtual Assistant', 
               50, 
               doc.page.height - 30, 
               { align: 'center' });

      doc.end();
    } catch (error) {
      reject(error);
    }
  });
};

const generateWordReport = async (conversation, options = {}) => {
  try {
    const doc = new Document({
      sections: [{
        properties: {},
        children: [
          // Title
          new Paragraph({
            text: "EVA ERP Consultation Report",
            heading: HeadingLevel.TITLE,
            alignment: "center"
          }),
          
          new Paragraph({
            text: `Generated on: ${new Date().toLocaleDateString()}`,
            alignment: "center",
            spacing: { after: 400 }
          }),

          // Business Requirements
          ...(conversation.requirements ? [
            new Paragraph({
              text: "Business Requirements",
              heading: HeadingLevel.HEADING_1
            }),
            new Paragraph({
              children: [
                new TextRun({ text: "Business Type: ", bold: true }),
                new TextRun(conversation.requirements.businessType)
              ]
            }),
            new Paragraph({
              children: [
                new TextRun({ text: "Current System: ", bold: true }),
                new TextRun(conversation.requirements.currentSystem)
              ]
            }),
            ...(conversation.requirements.budget ? [
              new Paragraph({
                children: [
                  new TextRun({ text: "Budget: ", bold: true }),
                  new TextRun(conversation.requirements.budget)
                ]
              })
            ] : []),
            new Paragraph({ text: "", spacing: { after: 200 } })
          ] : []),

          // Consultation Transcript
          new Paragraph({
            text: "Consultation Transcript",
            heading: HeadingLevel.HEADING_1
          }),

          ...conversation.messages.flatMap(message => [
            new Paragraph({
              children: [
                new TextRun({ 
                  text: message.role === 'user' ? 'Client: ' : 'EVA: ',
                  bold: true,
                  color: message.role === 'user' ? '059669' : '3B82F6'
                })
              ]
            }),
            new Paragraph({
              text: message.content,
              spacing: { after: 200 }
            })
          ]),

          // Code snippets
          ...(options.includeCode && conversation.codeSnippets ? [
            new Paragraph({
              text: "Generated Code Snippets",
              heading: HeadingLevel.HEADING_1
            }),
            ...conversation.codeSnippets.flatMap(snippet => [
              new Paragraph({
                children: [
                  new TextRun({ 
                    text: `${snippet.type.toUpperCase()} Code:`,
                    bold: true 
                  })
                ]
              }),
              new Paragraph({
                text: snippet.code,
                spacing: { after: 200 }
              })
            ])
          ] : [])
        ]
      }]
    });

    const buffer = await Packer.toBuffer(doc);
    return buffer;
  } catch (error) {
    throw new Error(`Failed to generate Word document: ${error.message}`);
  }
};

const generateJSONReport = (conversation, options = {}) => {
  const report = {
    metadata: {
      generatedAt: new Date().toISOString(),
      conversationId: conversation.id,
      persona: conversation.persona,
      format: 'json'
    },
    businessRequirements: conversation.requirements || null,
    messages: conversation.messages.map(msg => ({
      role: msg.role,
      content: msg.content,
      timestamp: msg.timestamp
    })),
    analysis: conversation.analysis || null
  };

  if (options.includeCode && conversation.codeSnippets) {
    report.codeSnippets = conversation.codeSnippets;
  }

  return JSON.stringify(report, null, 2);
};

const formatPersonaName = (persona) => {
  const personas = {
    'sap_consultant': 'SAP Consultant',
    'oracle_specialist': 'Oracle Specialist',
    'dynamics_expert': 'Microsoft Dynamics Expert',
    'erp_architect': 'ERP Architect',
    'implementation_lead': 'Implementation Lead'
  };
  
  return personas[persona] || 'ERP Consultant';
};

const saveExportFile = async (buffer, filename, format) => {
  const uploadsDir = path.join(__dirname, '..', 'uploads');
  
  // Ensure uploads directory exists
  if (!fs.existsSync(uploadsDir)) {
    fs.mkdirSync(uploadsDir, { recursive: true });
  }
  
  const filepath = path.join(uploadsDir, `${filename}.${format}`);
  
  if (format === 'json') {
    fs.writeFileSync(filepath, buffer);
  } else {
    fs.writeFileSync(filepath, buffer);
  }
  
  return filepath;
};

const cleanupExportFile = (filepath) => {
  try {
    if (fs.existsSync(filepath)) {
      fs.unlinkSync(filepath);
    }
  } catch (error) {
    console.error('Error cleaning up export file:', error);
  }
};

const getExportMimeType = (format) => {
  const mimeTypes = {
    'pdf': 'application/pdf',
    'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'json': 'application/json'
  };
  
  return mimeTypes[format] || 'application/octet-stream';
};

module.exports = {
  generatePDFReport,
  generateWordReport,
  generateJSONReport,
  formatPersonaName,
  saveExportFile,
  cleanupExportFile,
  getExportMimeType
};